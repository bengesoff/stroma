// Generated by CoffeeScript 1.4.0
var Connection, HttpConnection, TcpConnection, ar, aropt, cursors, deconstructDatum, err, events, mkAtom, mkErr, mkSeq, net, pb, r, util, varar,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

net = require('net');

events = require('events');

util = require('./util');

err = require('./errors');

cursors = require('./cursor');

pb = require('./protobuf');

r = require('./ast');

ar = util.ar;

varar = util.varar;

aropt = util.aropt;

deconstructDatum = util.deconstructDatum;

mkAtom = util.mkAtom;

mkErr = util.mkErr;

mkSeq = util.mkSeq;

Connection = (function(_super) {

  __extends(Connection, _super);

  Connection.prototype.DEFAULT_HOST = 'localhost';

  Connection.prototype.DEFAULT_PORT = 28015;

  Connection.prototype.DEFAULT_AUTH_KEY = '';

  Connection.prototype.DEFAULT_TIMEOUT = 20;

  function Connection(host, callback) {
    var conCallback, errCallback,
      _this = this;
    if (typeof host === 'undefined') {
      host = {};
    } else if (typeof host === 'string') {
      host = {
        host: host
      };
    }
    this.host = host.host || this.DEFAULT_HOST;
    this.port = host.port || this.DEFAULT_PORT;
    this.db = host.db;
    this.authKey = host.authKey || this.DEFAULT_AUTH_KEY;
    this.timeout = host.timeout || this.DEFAULT_TIMEOUT;
    this.outstandingCallbacks = {};
    this.nextToken = 1;
    this.open = false;
    this.buffer = new Buffer(0);
    this._events = this._events || {};
    errCallback = function(e) {
      _this.removeListener('connect', conCallback);
      if (e instanceof err.RqlDriverError) {
        return callback(e);
      } else {
        return callback(new err.RqlDriverError("Could not connect to " + _this.host + ":" + _this.port + "."));
      }
    };
    this.once('error', errCallback);
    conCallback = function() {
      _this.removeListener('error', errCallback);
      _this.open = true;
      return callback(null, _this);
    };
    this.once('connect', conCallback);
  }

  Connection.prototype._data = function(buf) {
    var response, responseBuffer, responseLength, _results;
    this.buffer = Buffer.concat([this.buffer, buf]);
    _results = [];
    while (this.buffer.length >= 4) {
      responseLength = this.buffer.readUInt32LE(0);
      if (!(this.buffer.length >= (4 + responseLength))) {
        break;
      }
      responseBuffer = this.buffer.slice(4, responseLength + 4);
      response = pb.ParseResponse(responseBuffer);
      this._processResponse(response);
      _results.push(this.buffer = this.buffer.slice(4 + responseLength));
    }
    return _results;
  };

  Connection.prototype._delQuery = function(token) {
    delete this.outstandingCallbacks[token];
    if (Object.keys(this.outstandingCallbacks).length < 1 && !this.open) {
      return this.cancel();
    }
  };

  Connection.prototype._processResponse = function(response) {
    var cb, cursor, opts, profile, root, token, _ref,
      _this = this;
    token = response.token;
    profile = response.profile;
    if (profile != null) {
      profile = deconstructDatum(profile, {});
    }
    if (this.outstandingCallbacks[token] != null) {
      _ref = this.outstandingCallbacks[token], cb = _ref.cb, root = _ref.root, cursor = _ref.cursor, opts = _ref.opts;
      if (cursor != null) {
        cursor._addResponse(response);
        if (cursor._endFlag && cursor._outstandingRequests === 0) {
          return this._delQuery(token);
        }
      } else if (cb != null) {
        return pb.ResponseTypeSwitch(response, {
          "COMPILE_ERROR": function() {
            cb(mkErr(err.RqlCompileError, response, root));
            return _this._delQuery(token);
          },
          "CLIENT_ERROR": function() {
            cb(mkErr(err.RqlClientError, response, root));
            return _this._delQuery(token);
          },
          "RUNTIME_ERROR": function() {
            cb(mkErr(err.RqlRuntimeError, response, root));
            return _this._delQuery(token);
          },
          "SUCCESS_ATOM": function() {
            response = mkAtom(response, opts);
            if (Array.isArray(response)) {
              response = cursors.makeIterable(response);
            }
            if (profile != null) {
              response = {
                profile: profile,
                value: response
              };
            }
            cb(null, response);
            return _this._delQuery(token);
          },
          "SUCCESS_PARTIAL": function() {
            cursor = new cursors.Cursor(_this, token, opts, root);
            _this.outstandingCallbacks[token].cursor = cursor;
            if (profile != null) {
              return cb(null, {
                profile: profile,
                value: cursor._addResponse(response)
              });
            } else {
              return cb(null, cursor._addResponse(response));
            }
          },
          "SUCCESS_SEQUENCE": function() {
            cursor = new cursors.Cursor(_this, token, opts, root);
            _this._delQuery(token);
            if (profile != null) {
              return cb(null, {
                profile: profile,
                value: cursor._addResponse(response)
              });
            } else {
              return cb(null, cursor._addResponse(response));
            }
          },
          "WAIT_COMPLETE": function() {
            _this._delQuery(token);
            return cb(null, null);
          }
        }, function() {
          return cb(new err.RqlDriverError("Unknown response type"));
        });
      }
    } else {
      return this.emit('error', new err.RqlDriverError("Unexpected token " + token + "."));
    }
  };

  Connection.prototype.close = varar(0, 2, function(optsOrCallback, callback) {
    var cb, key, noreplyWait, opts, wrappedCb,
      _this = this;
    if (callback != null) {
      opts = optsOrCallback;
      if (Object.prototype.toString.call(opts) !== '[object Object]') {
        throw new err.RqlDriverError("First argument to two-argument `close` must be an object.");
      }
      cb = callback;
    } else if (Object.prototype.toString.call(optsOrCallback) === '[object Object]') {
      opts = optsOrCallback;
      cb = null;
    } else {
      opts = {};
      cb = optsOrCallback;
    }
    for (key in opts) {
      if (!__hasProp.call(opts, key)) continue;
      if (key !== 'noreplyWait') {
        throw new err.RqlDriverError("First argument to two-argument `close` must be { noreplyWait: <bool> }.");
      }
    }
    if (!(!(cb != null) || typeof cb === 'function')) {
      throw new err.RqlDriverError("Final argument to `close` must be a callback function or object.");
    }
    wrappedCb = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      _this.open = false;
      if (cb != null) {
        return cb.apply(null, args);
      }
    };
    noreplyWait = ((!(opts.noreplyWait != null)) || opts.noreplyWait) && this.open;
    if (noreplyWait) {
      return this.noreplyWait(wrappedCb);
    } else {
      return wrappedCb();
    }
  });

  Connection.prototype.noreplyWait = ar(function(callback) {
    var query, token;
    if (typeof callback !== 'function') {
      throw new err.RqlDriverError("First argument to noreplyWait must be a callback function.");
    }
    if (!this.open) {
      callback(new err.RqlDriverError("Connection is closed."));
      return;
    }
    token = this.nextToken++;
    query = {};
    query.type = "NOREPLY_WAIT";
    query.token = token;
    this.outstandingCallbacks[token] = {
      cb: callback,
      root: null,
      opts: null
    };
    return this._sendQuery(query);
  });

  Connection.prototype.cancel = ar(function() {
    return this.outstandingCallbacks = {};
  });

  Connection.prototype.reconnect = varar(1, 2, function(optsOrCallback, callback) {
    var cb, closeCb, opts,
      _this = this;
    if (callback != null) {
      opts = optsOrCallback;
      cb = callback;
    } else {
      opts = {};
      cb = optsOrCallback;
    }
    if (typeof cb !== 'function') {
      throw new err.RqlDriverError("Final argument to `reconnect` must be a callback function.");
    }
    closeCb = function(err) {
      var constructCb;
      if (err != null) {
        return cb(err);
      } else {
        constructCb = function() {
          return _this.constructor.call(_this, {
            host: _this.host,
            port: _this.port
          }, cb);
        };
        return setTimeout(constructCb, 0);
      }
    };
    return this.close(opts, closeCb);
  });

  Connection.prototype.use = ar(function(db) {
    return this.db = db;
  });

  Connection.prototype._start = function(term, cb, opts) {
    var pair, query, token;
    if (!this.open) {
      throw new err.RqlDriverError("Connection is closed.");
    }
    token = this.nextToken++;
    query = {
      'global_optargs': []
    };
    query.type = "START";
    query.query = term.build();
    query.token = token;
    if (this.db != null) {
      pair = {
        key: 'db',
        val: r.db(this.db).build()
      };
      query.global_optargs.push(pair);
    }
    if (opts.useOutdated != null) {
      pair = {
        key: 'use_outdated',
        val: r.expr(!!opts.useOutdated).build()
      };
      query.global_optargs.push(pair);
    }
    if (opts.noreply != null) {
      pair = {
        key: 'noreply',
        val: r.expr(!!opts.noreply).build()
      };
      query.global_optargs.push(pair);
    }
    if (opts.profile != null) {
      pair = {
        key: 'profile',
        val: r.expr(!!opts.profile).build()
      };
      query.global_optargs.push(pair);
    }
    if (opts.durability != null) {
      pair = {
        key: 'durability',
        val: r.expr(opts.durability).build()
      };
      query.global_optargs.push(pair);
    }
    if ((!(opts.noreply != null)) || !opts.noreply) {
      this.outstandingCallbacks[token] = {
        cb: cb,
        root: term,
        opts: opts
      };
    }
    this._sendQuery(query);
    if ((opts.noreply != null) && opts.noreply && typeof cb === 'function') {
      return cb(null);
    }
  };

  Connection.prototype._continueQuery = function(token) {
    var query;
    query = {
      type: "CONTINUE",
      token: token
    };
    return this._sendQuery(query);
  };

  Connection.prototype._endQuery = function(token) {
    var query;
    query = {
      type: "STOP",
      token: token
    };
    return this._sendQuery(query);
  };

  Connection.prototype._sendQuery = function(query) {
    var data, i, lengthBuffer, totalBuf;
    query.accepts_r_json = true;
    data = pb.SerializeQuery(query);
    if (pb.protobuf_implementation === 'cpp') {
      lengthBuffer = new Buffer(4);
      lengthBuffer.writeUInt32LE(data.length, 0);
      totalBuf = Buffer.concat([lengthBuffer, data]);
    } else {
      totalBuf = new Buffer(data.length + 4);
      totalBuf.writeUInt32LE(data.length, 0);
      i = 0;
      while (i < data.length) {
        totalBuf.set(i + 4, data.get(i));
        i++;
      }
    }
    return this.write(totalBuf);
  };

  return Connection;

})(events.EventEmitter);

TcpConnection = (function(_super) {

  __extends(TcpConnection, _super);

  TcpConnection.isAvailable = function() {
    return !process.browser;
  };

  function TcpConnection(host, callback) {
    var timeout,
      _this = this;
    if (!TcpConnection.isAvailable()) {
      throw new err.RqlDriverError("TCP sockets are not available in this environment");
    }
    TcpConnection.__super__.constructor.call(this, host, callback);
    if (this.rawSocket != null) {
      this.close({
        noreplyWait: false
      });
    }
    this.rawSocket = net.connect(this.port, this.host);
    this.rawSocket.setNoDelay();
    timeout = setTimeout((function() {
      _this.rawSocket.destroy();
      return _this.emit('error', new err.RqlDriverError("Handshake timedout"));
    }), this.timeout * 1000);
    this.rawSocket.once('error', function() {
      return clearTimeout(timeout);
    });
    this.rawSocket.once('connect', function() {
      var buf, handshake_callback;
      buf = new Buffer(8);
      buf.writeUInt32LE(0x723081e1, 0);
      buf.writeUInt32LE(_this.authKey.length, 4);
      _this.write(buf);
      _this.rawSocket.write(_this.authKey, 'ascii');
      handshake_callback = function(buf) {
        var b, i, status_buf, status_str, _i, _len, _ref;
        _this.buffer = Buffer.concat([_this.buffer, buf]);
        _ref = _this.buffer;
        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
          b = _ref[i];
          if (b === 0) {
            _this.rawSocket.removeListener('data', handshake_callback);
            status_buf = _this.buffer.slice(0, i);
            _this.buffer = _this.buffer.slice(i + 1);
            status_str = status_buf.toString();
            clearTimeout(timeout);
            if (status_str === "SUCCESS") {
              _this.rawSocket.on('data', function(buf) {
                return _this._data(buf);
              });
              _this.emit('connect');
              return;
            } else {
              _this.emit('error', new err.RqlDriverError("Server dropped connection with message: \"" + status_str.trim() + "\""));
              return;
            }
          }
        }
      };
      return _this.rawSocket.on('data', handshake_callback);
    });
    this.rawSocket.on('error', function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return _this.emit.apply(_this, ['error'].concat(__slice.call(args)));
    });
    this.rawSocket.on('close', function() {
      _this.open = false;
      return _this.emit('close', {
        noreplyWait: false
      });
    });
  }

  TcpConnection.prototype.close = varar(0, 2, function(optsOrCallback, callback) {
    var cb, opts, wrappedCb,
      _this = this;
    if (callback != null) {
      opts = optsOrCallback;
      cb = callback;
    } else if (Object.prototype.toString.call(optsOrCallback) === '[object Object]') {
      opts = optsOrCallback;
      cb = null;
    } else {
      opts = {};
      cb = optsOrCallback;
    }
    if (!(!(cb != null) || typeof cb === 'function')) {
      throw new err.RqlDriverError("Final argument to `close` must be a callback function or object.");
    }
    wrappedCb = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      _this.rawSocket.end();
      if (cb != null) {
        return cb.apply(null, args);
      }
    };
    return TcpConnection.__super__.close.call(this, opts, wrappedCb);
  });

  TcpConnection.prototype.cancel = function() {
    this.rawSocket.destroy();
    return TcpConnection.__super__.cancel.call(this);
  };

  TcpConnection.prototype.write = function(chunk) {
    return this.rawSocket.write(chunk);
  };

  return TcpConnection;

})(Connection);

HttpConnection = (function(_super) {

  __extends(HttpConnection, _super);

  HttpConnection.prototype.DEFAULT_PROTOCOL = 'http';

  HttpConnection.isAvailable = function() {
    return typeof XMLHttpRequest !== "undefined";
  };

  function HttpConnection(host, callback) {
    var protocol, url, xhr,
      _this = this;
    if (!HttpConnection.isAvailable()) {
      throw new err.RqlDriverError("XMLHttpRequest is not available in this environment");
    }
    HttpConnection.__super__.constructor.call(this, host, callback);
    protocol = host.protocol === 'https' ? 'https' : this.DEFAULT_PROTOCOL;
    url = "" + protocol + "://" + this.host + ":" + this.port + host.pathname + "ajax/reql/";
    xhr = new XMLHttpRequest;
    xhr.open("GET", url + "open-new-connection", true);
    xhr.responseType = "arraybuffer";
    xhr.onreadystatechange = function(e) {
      if (xhr.readyState === 4) {
        if (xhr.status === 200) {
          _this._url = url;
          _this._connId = (new DataView(xhr.response)).getInt32(0, true);
          return _this.emit('connect');
        } else {
          return _this.emit('error', new err.RqlDriverError("XHR error, http status " + xhr.status + "."));
        }
      }
    };
    xhr.send();
  }

  HttpConnection.prototype.cancel = function() {
    var xhr;
    xhr = new XMLHttpRequest;
    xhr.open("POST", "" + this._url + "close-connection?conn_id=" + this._connId, true);
    xhr.send();
    this._url = null;
    this._connId = null;
    return HttpConnection.__super__.cancel.call(this);
  };

  HttpConnection.prototype.write = function(chunk) {
    var array, i, view, xhr,
      _this = this;
    xhr = new XMLHttpRequest;
    xhr.open("POST", "" + this._url + "?conn_id=" + this._connId, true);
    xhr.responseType = "arraybuffer";
    xhr.onreadystatechange = function(e) {
      var b, buf;
      if (xhr.readyState === 4 && xhr.status === 200) {
        buf = new Buffer((function() {
          var _i, _len, _ref, _results;
          _ref = new Uint8Array(xhr.response);
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            b = _ref[_i];
            _results.push(b);
          }
          return _results;
        })());
        return _this._data(buf);
      }
    };
    array = new ArrayBuffer(chunk.length);
    view = new Uint8Array(array);
    i = 0;
    while (i < chunk.length) {
      view[i] = chunk.get(i);
      i++;
    }
    return xhr.send(array);
  };

  return HttpConnection;

})(Connection);

module.exports.connect = ar(function(host, callback) {
  if (!(typeof host === 'string' || Object.prototype.toString.call(host) === '[object Object]')) {
    throw new err.RqlDriverError("First argument to `connect` must be a string giving the " + "host to `connect` to or an object giving `host` and `port`.");
  }
  if (typeof callback !== 'function') {
    throw new err.RqlDriverError("Second argument to `connect` must be a callback to invoke with " + "either an error or the successfully established connection.");
  }
  if (TcpConnection.isAvailable()) {
    new TcpConnection(host, callback);
  } else if (HttpConnection.isAvailable()) {
    new HttpConnection(host, callback);
  } else {
    throw new err.RqlDriverError("Neither TCP nor HTTP avaiable in this environment");
  }
});

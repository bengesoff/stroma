// Generated by CoffeeScript 1.4.0
var native_pb, pb, protodef,
  __hasProp = {}.hasOwnProperty;

pb = require('protobufjs');

try {
  native_pb = require('./native-protobuf');
} catch (err) {
  native_pb = {};
}

if (native_pb.SerializeQuery != null) {
  module.exports.protobuf_implementation = "cpp";
} else {
  module.exports.protobuf_implementation = "js";
}

protodef = require('./proto-def');

module.exports.SerializeQuery = function(query) {
  var querypb;
  if (native_pb.SerializeQuery != null) {
    return native_pb.SerializeQuery(query);
  } else {
    querypb = new protodef.Query(query);
    return querypb.toBuffer();
  }
};

module.exports.ParseResponse = function(data) {
  var array, i, response, view;
  if (native_pb.ParseResponse != null) {
    return native_pb.ParseResponse(data);
  } else {
    array = new ArrayBuffer(data.length);
    view = new Uint8Array(array);
    i = 0;
    while (i < data.length) {
      view[i] = data.get(i);
      i++;
    }
    response = protodef.Response.decode(array);
    response.token = response.token.toInt();
    return response;
  }
};

module.exports.ResponseTypeSwitch = function(response, map, dflt) {
  var type, type_str, type_val, _ref;
  type = response.type;
  if (typeof type === 'string') {
    type = protodef.Response.ResponseType[type];
  }
  _ref = protodef.Response.ResponseType;
  for (type_str in _ref) {
    if (!__hasProp.call(_ref, type_str)) continue;
    type_val = _ref[type_str];
    if (type === type_val) {
      if (map[type_str] != null) {
        return map[type_str]();
      } else {
        break;
      }
    }
  }
  return dflt();
};

module.exports.DatumTypeSwitch = function(datum, map, dflt) {
  var type, type_str, type_val, _ref;
  type = datum.type;
  if (typeof type === 'string') {
    type = protodef.Datum.DatumType[type];
  }
  _ref = protodef.Datum.DatumType;
  for (type_str in _ref) {
    if (!__hasProp.call(_ref, type_str)) continue;
    type_val = _ref[type_str];
    if (type === type_val) {
      if (map[type_str] != null) {
        return map[type_str]();
      } else {
        break;
      }
    }
  }
  return dflt();
};
